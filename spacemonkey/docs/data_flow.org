# Data Flow

## 1. Haskell -> Elm (Client Types and JSON De/Serialization + REST API Calls)

1. Specifications for Haskell data types in `src/Modules/` -- see also section 3
2. Specifications for generating bindings for Haskell data types in `make/Make/`
3. `make/Main.hs` should run one or more of the make scripts in `make/Make/`
4. The Elm generated files generated by Step 3 are ready for use

The `spacemonkey/redo.all` script has the shell commands for all steps, from `stack install`, to running the excecutable, to moving the generated Elm files. 

**P.S.**

For more complex APIs and/or use with persistence using the `persistent` library (see below), the `servant-elm` module (and underlying `elm-bridge`) used for code gen may have shortcomings.

`make/Make/Spacemonkey.hs` has an example of using some type name replacements, to be used in conjunction with post-code-gen text additions and replacements specified in `scripts/PostCodeGen.hs`.


<hr>

## 2. Haskell -> Haskell (Server JSON De/Serialization)

The definition of the Servant server, as well some definitions for `fromHttpApiData` and `toHttpApiData` ([see docs](https://docs.servant.dev/en/stable/tutorial/Server.html#the-fromhttpapidata-tohttpapidata-classes)) for non-primitive types suffices; no explicit JSON handling is required.


## 3. Haskell <> Persistence

In the case of using the [`persistent` library](https://www.yesodweb.com/book/persistent) for interacting with a supported database backedn like Sqlite:

1. Specifications for Haskell data types in `src/Modules/` -- this is the same specification as in section 1, though `persistent` requires its own Template Haskell format rather than native Haskell data specifications
2. The database handlers, as well as initialization / migration and server-database interactions, are handled in the `server/Server` modules -- no SQL data definitions are required (though manual schema setup is supported, if so desired for say Production deployment)

